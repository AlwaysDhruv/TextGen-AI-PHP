<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TextGen-AI Chat</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="chat-header">
        <div class="chat-title">
            <div class="ai-icon">TG</div>
            TextGen-AI
        </div>
        <div class="model-selector">
            <select class="model-dropdown" id="modelSelect">
                <option value="">Loading models...</option>
            </select>
            <button class="refresh-button" id="refreshButton" title="Refresh models list">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
                </svg>
            </button>
            <div class="status-indicator status-offline" id="statusIndicator">
                Offline
            </div>
        </div>
    </div>

    <div class="chat-container">
        <div class="error-message" id="errorMessage"></div>
        <div class="chat-messages" id="chatMessages">
            <div class="welcome-message-container">
                <div class="welcome-message">
                    <div class="welcome-title">Welcome to TextGen-AI Chat</div>
                    <p>Select a model from the dropdown above and start chatting with your local AI assistant!</p>
                    <p>Make sure Ollama is running on your system with: <code>ollama serve</code></p>
                    <p>If no models appear, pull one first: <code>ollama pull Model_Name</code></p>
                </div>
            </div>
        </div>
        <div class="typing-indicator" id="typingIndicator">
            <div class="message-avatar ai-avatar">TG</div>
            <div class="typing-dots">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
            </div>
        </div>
        <div class="chat-input-container">
            <div class="chat-input-wrapper">
                <textarea class="chat-input" id="chatInput" placeholder="Type your message here..." rows="1"></textarea>
                <button class="send-button" id="sendButton" disabled>
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M2 21l21-9L2 3v7l15 2-15 2v7z"/>
                    </svg>
                </button>
                <button class="stop-button" id="stopButton" title="Stop generating">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M6 6h12v12H6z"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>
    
    <script>
        class OllamaChat {
            constructor() {
                this.messages = [];
                this.currentModel = '';
                this.isTyping = false;
                this.availableModels = [];
                this.stopController = null;
                this.typingInterval = null;

                this.initializeElements();
                this.attachEventListeners();
                this.initializeApp();
                
                this.chatInput.addEventListener('input', this.autoResizeTextarea.bind(this));
            }

            async initializeApp() {
                await this.checkOllamaStatus();
                await this.loadAvailableModels();
                this.displayGreeting();
            }

            initializeElements() {
                this.chatMessages = document.getElementById('chatMessages');
                this.chatInput = document.getElementById('chatInput');
                this.sendButton = document.getElementById('sendButton');
                this.stopButton = document.getElementById('stopButton');
                this.modelSelect = document.getElementById('modelSelect');
                this.refreshButton = document.getElementById('refreshButton');
                this.statusIndicator = document.getElementById('statusIndicator');
                this.typingIndicator = document.getElementById('typingIndicator');
                this.errorMessage = document.getElementById('errorMessage');
            }

            attachEventListeners() {
                this.sendButton.addEventListener('click', this.sendMessage.bind(this));
                this.stopButton.addEventListener('click', this.stopGenerating.bind(this));
                this.chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });

                this.modelSelect.addEventListener('change', this.handleModelChange.bind(this));
                this.refreshButton.addEventListener('click', this.refreshModels.bind(this));
                this.chatInput.addEventListener('input', this.handleInputChange.bind(this));
            }
            
            async loadAvailableModels() {
                try {
                    const response = await fetch('chat.php', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            action: 'get_models'
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success && data.models) {
                        this.availableModels = data.models;
                        this.populateModelDropdown();
                    } else {
                        this.showNoModelsMessage();
                    }
                } catch (error) {
                    console.error('Error loading models:', error);
                    this.showNoModelsMessage();
                }
            }

            populateModelDropdown() {
                this.modelSelect.innerHTML = '';
                
                if (this.availableModels.length === 0) {
                    this.modelSelect.innerHTML = '<option value="">No models available</option>';
                    return;
                }
                
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = 'Select a model';
                this.modelSelect.appendChild(defaultOption);
                
                this.availableModels.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.name;

                    const displayName = this.formatModelName(model.name, model.size);
                    option.textContent = displayName;
                    
                    this.modelSelect.appendChild(option);
                });
                
                this.updateStatus('online', `${this.availableModels.length} models available`);
            }
            
            formatModelName(name, size) {
                let displayName = name;
                displayName = displayName.replace(/:latest$/, '');
                
                if (size) {
                    const sizeGB = (size / (1024 * 1024 * 1024)).toFixed(1);
                    displayName += ` (${sizeGB}GB)`;
                }

                displayName = displayName.charAt(0).toUpperCase() + displayName.slice(1);
                displayName = displayName.replace(/[-_]/g, ' ');

                return displayName;
            }
            
            showNoModelsMessage() {
                this.modelSelect.innerHTML = '<option value="">No models found</option>';
                this.updateStatus('offline', 'No models');
                this.showError('No models found locally. Pull a model first with: ollama pull llama2');
            }

            handleModelChange() {
                this.currentModel = this.modelSelect.value;
                if (this.currentModel) {
                    this.sendButton.disabled = false;
                    this.chatInput.disabled = false;
                    this.hideError();
                    
                    const selectedModel = this.availableModels.find(m => m.name === this.currentModel);
                    if (selectedModel) {
                        this.updateStatus('online', `Ready - ${this.formatModelName(selectedModel.name, selectedModel.size)}`);
                    }
                } else {
                    this.sendButton.disabled = true;
                    this.chatInput.disabled = true;
                    this.updateStatus('online', `${this.availableModels.length} models available`);
                }
            }
            
            async refreshModels() {
                this.refreshButton.disabled = true;
                this.modelSelect.innerHTML = '<option value="">Refreshing...</option>';
                this.updateStatus('offline', 'Refreshing...');
                
                await this.loadAvailableModels();
                
                this.refreshButton.disabled = false;
            }

            handleInputChange() {
                const hasText = this.chatInput.value.trim().length > 0;
                if (!this.isTyping) {
                    this.sendButton.style.display = hasText ? 'flex' : 'none';
                    this.stopButton.style.display = 'none';
                }
            }
            
            autoResizeTextarea() {
                this.chatInput.style.height = 'auto';
                this.chatInput.style.height = Math.min(this.chatInput.scrollHeight, 120) + 'px';
            }
            
            async checkOllamaStatus() {
                try {
                    const response = await fetch('chat.php', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            action: 'check_status'
                        })
                    });

                    const data = await response.json();
                    
                    if (data.success) {
                        this.updateStatus('online', 'Online');
                        return true;
                    } else {
                        this.updateStatus('offline', 'Offline');
                        this.showError('Ollama server is not running. Please start with: ollama serve');
                        return false;
                    }
                } catch (error) {
                    this.updateStatus('offline', 'Offline');
                    this.showError('Cannot connect to Ollama API');
                    return false;
                }
            }

            updateStatus(status, text) {
                this.statusIndicator.className = `status-indicator status-${status}`;
                this.statusIndicator.textContent = text;
            }

            showError(message) {
                this.errorMessage.textContent = message;
                this.errorMessage.style.display = 'block';
            }

            hideError() {
                this.errorMessage.style.display = 'none';
            }

            async sendMessage() {
                const message = this.chatInput.value.trim();
                if (!message || !this.currentModel || this.isTyping) return;
                
                this.addMessage('user', message);
                this.chatInput.value = '';
                this.autoResizeTextarea();
                
                const welcomeContainer = document.querySelector('.welcome-message-container');
                if (welcomeContainer) {
                    welcomeContainer.remove();
                    this.chatMessages.style.justifyContent = 'flex-start';
                    this.chatMessages.style.alignItems = 'flex-start';
                }
                
                this.startGenerating();
                
                this.stopController = new AbortController();
                const signal = this.stopController.signal;

                try {
                    const response = await fetch('chat.php', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            action: 'chat',
                            model: this.currentModel,
                            message: message,
                            history: this.messages.slice(-10)
                        }),
                        signal: signal
                    });

                    const data = await response.json();
                    
                    this.stopGenerating();
                    
                    if (data.success) {
                        this.addAnimatedMessage('ai', data.response);
                    } else {
                        this.addMessage('ai', `Error: ${data.message}`);
                        this.showError(data.message);
                    }
                } catch (error) {
                    this.stopGenerating();
                    if (error.name !== 'AbortError') {
                        this.addMessage('ai', 'Sorry, I encountered an error processing your request.');
                        this.showError('Network error occurred');
                    } else {
                        this.addMessage('ai', 'Generation stopped by user.');
                    }
                }
            }

            startGenerating() {
                this.isTyping = true;
                this.sendButton.style.display = 'none';
                this.stopButton.style.display = 'flex';
                this.showTyping();
            }

            stopGenerating() {
                if (this.stopController) {
                    this.stopController.abort();
                }
                this.isTyping = false;
                this.hideTyping();
                this.handleInputChange();
            }

            addMessage(sender, content) {
                const message = {
                    sender,
                    content,
                    timestamp: new Date()
                };

                this.messages.push(message);

                const messageElement = this.createMessageElement(message);
                this.chatMessages.appendChild(messageElement);
                this.scrollToBottom();
            }

            async addAnimatedMessage(sender, content) {
                const message = {
                    sender,
                    content,
                    timestamp: new Date()
                };

                this.messages.push(message);

                const messageElement = this.createMessageElement(message, true);
                this.chatMessages.appendChild(messageElement);
                
                const contentDiv = messageElement.querySelector('.message-content');
                
                await this.typeWriterEffect(content, contentDiv);
                
                this.scrollToBottom();
            }

            createMessageElement(message, animate = false) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${message.sender}`;

                const avatar = document.createElement('div');
                avatar.className = `message-avatar ${message.sender}-avatar`;
                avatar.textContent = message.sender === 'user' ? 'U' : 'AI';

                const content = document.createElement('div');
                content.className = 'message-content';
                
                if (!animate) {
                    content.innerHTML = this.formatMessage(message.content);
                } else {
                    content.innerHTML = '';
                }

                const time = document.createElement('div');
                time.className = 'message-time';
                time.textContent = this.formatTime(message.timestamp);
                
                if (message.sender === 'ai') {
                    const copyButton = document.createElement('button');
                    copyButton.className = 'copy-button';
                    copyButton.innerHTML = `<svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>
                    </svg>`;
                    copyButton.title = 'Copy to clipboard';

                    copyButton.addEventListener('click', () => {
                        this.copyToClipboard(message.content, copyButton);
                    });

                    messageDiv.appendChild(copyButton);
                }

                content.appendChild(time);
                messageDiv.appendChild(avatar);
                messageDiv.appendChild(content);

                return messageDiv;
            }

            async copyToClipboard(text, button) {
                try {
                    await navigator.clipboard.writeText(text);
                    button.classList.add('copied');
                    button.title = 'Copied!';
                    setTimeout(() => {
                        button.classList.remove('copied');
                        button.title = 'Copy to clipboard';
                    }, 2000);
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                    button.title = 'Failed to copy!';
                }
            }

            async typeWriterEffect(text, element) {
                const formattedText = this.formatMessage(text);
                const characters = formattedText.split('');
                let i = 0;

                return new Promise(resolve => {
                    this.typingInterval = setInterval(() => {
                        if (i < characters.length) {
                            element.innerHTML += characters[i];
                            i++;
                            this.scrollToBottom();
                        } else {
                            clearInterval(this.typingInterval);
                            this.typingInterval = null;
                            resolve();
                        }
                    }, 5);
                });
            }

            formatMessage(content) {
                return content
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/`(.*?)`/g, '<code>$1</code>')
                    .replace(/\n/g, '<br>');
            }

            formatTime(date) {
                return date.toLocaleTimeString([], {
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }

            showTyping() {
                this.isTyping = true;
                this.typingIndicator.style.display = 'flex';
                this.chatInput.disabled = true;
                this.scrollToBottom();
            }

            hideTyping() {
                this.isTyping = false;
                this.typingIndicator.style.display = 'none';
                this.chatInput.disabled = false;
                if (this.typingInterval) {
                    clearInterval(this.typingInterval);
                    this.typingInterval = null;
                }
            }

            scrollToBottom() {
                setTimeout(() => {
                    this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
                }, 100);
            }

            displayGreeting() {
                const { title: greetingTitle } = this.getGreeting();
                const welcomeContainer = document.querySelector('.welcome-message-container');
                
                if (welcomeContainer) {
                    const welcomeMessage = welcomeContainer.querySelector('.welcome-message');
                    
                    const greetingElement = document.createElement('p');
                    greetingElement.className = 'greeting-message';
                    greetingElement.innerHTML = greetingTitle;

                    welcomeMessage.prepend(greetingElement);
                }
            }

            getGreeting() {
                const hour = new Date().getHours();
                if (hour < 12) {
                    return {
                        title: 'Good Morning! ☀️',
                        message: 'Ready to tackle the day? Ask me anything!'
                    };
                } else if (hour < 18) {
                    return {
                        title: 'Good Afternoon! 👋',
                        message: 'Need help with something? I\'m here to assist!'
                    };
                } else {
                    return {
                        title: 'Good Evening! 🌙',
                        message: 'What can I help you with tonight?'
                    };
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new OllamaChat();
        });
    </script>
</body>
</html>